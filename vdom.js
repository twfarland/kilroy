(function () {


    /*
    kilroy.vdom - holds the el and the vdom, runs anim frames. also has prep(), tohtml, tohtmlstr, update, d(), animate
    kilroy.events - binds the events. optional jquery adapter
    kilroy.component - groups and initialises
    kilroy.utils
    */





// for each tag, get all children at one level down


var el = new vDom(function (v) {
    return ['#123 .bleh', ]; 
});


// :: vDom -> vDom
// alters the vDom generated by the view function to one that can be compared and diff'd
// modifies v in place, and returns it

function prepVDom (v) {
    if (!isTag(v)) { return v; }
    prepAttributeShorthand(v);
    prepChildren(v);
    return v;
}

// :: vDom -> vDom
// on a vDom tag, extracts id and class shorthand, extending the object if any
// returns modified object

function prepAttributeShorthand (v) {

    var tag = v[0].split(/\s+/);

    if (tag.length > 1 || tag[0].charAt(0) === '#' || tag[0].charAt(0) === '.') {

        var attrs, a, attr, el = 'div';

        if (toString.call(v[1]) === '[object Object]') { 
            attrs = v[1];

        } else {
            attrs = {};
            v.splice(1, 0, attrs); 
        }

        for (a = 0; a < tag.length; a++) {

            attr = tag[a];

            if (attr.charAt(0) === '#') { 
                attrs.id = attr.slice(1);

            } else if (attr.charAt(0) === '.') { 
                attrs['class'] = (!attrs['class']) ? attr.slice(1) : attrs['class'] + ' ' + attr.slice(1);

            } else {
                el = attr;
            }   
        }

        v[0] = el;
    }

    return v;
}


function eq (a, b) {
    console.log(a, b);
}


eq(
    prepAttributeShorthand(['#someid .someclass', 123]),
    ['div', { id: 'someid', 'class': 'someclass' }, 123]
);

eq(
    prepAttributeShorthand(['div', 123]),
    ['div', 123]
);

eq(
    prepAttributeShorthand(['hr #someid .someclass .someclass', { name: 'blah' }]),
    ['hr', { name: 'blah', id: 'someid', 'class': 'someclass' }]
);


eq(
    prepVDom(
        ['div', 
            [['a', 123], 
            [[['b', 456]], 789]]]), 
    ['div', 
        ['a', 123], 
        ['b', 456], 
        789]
);

// unit test all functions



function vDom (view) {

    var v       = this;

    v.view      = view;
    v.virtual   = v.view();
    v.dom       = v.toHtml(v.virtual);

    if (window.requestAnimationFrame) animate(v); // expects polyfill

    return v;
}

vDom.prototype = {

    d: function () {

        this.dirty = true;
    },

    animate: function () {

        var v = this;

        v.animating = true;

        function frame () {

            if (!v.rendering && v.dirty) {
                v.rendering = true;
                v.render();
                v.rendering = false;
                v.dirty     = false;
            } 
            window.requestAnimationFrame(frame);
        }

        frame();
    },

    render: function () {

        var v = this,
        virtualNext = v.view();
   
        v.update(v.dom, v.virtual, virtualNext);
        v.virtual = virtualNext;
    },

    toHtmlString: function (v) {

        var k = this;

        if (isTag(v)) { // tag

            var tag = v[0],
                obj = v[1],
                attrs = [], a,
                children, c, cLength,
                res;

            if (_toString.call(obj) === '[object Object]') {
                for (a in obj) {
                    if (exists(obj[a]) && a[0] !== '_') attrs.push(a + '="' + obj[a] + '"');
                }
                children = v.slice(2);

            } else {
                children = v.slice(1);
            }

            cLength = children.length;

            res = '<' + [tag].concat(attrs).join(' ') + '>';
            for (c = 0; c < cLength; c++) res += k.toHtmlString(children[c]);
            if (cLength > 0) res += '</' + tag + '>'; 

            return res;

        } else if (typeof v === 'string') { // atom
            return v;

        } else if (v !== false && v !== null && typeof v !== 'undefined' && v.toString) {
            return v.toString();

        } else {
            return '';
        }
    }

};









vDom.prototype.toHtml = function (v) {

    var el = document.createElement('div');
    el.innerHTML = this.toHtmlStr(v);
    return el.firstChild;
};


// D is current real dom node
// A is current virtual dom node
// B is new virtual dom node

Kilroy.prototype.update = function (D, A, B) { 

    if (!D) return;

    var k = this,
        DChildren = [],
        AChildren, 
        AAttrs = {}, 
        AAttr,
        BChildren, 
        BAttrs = {}, 
        BAttr,
        CAttrs = {}, 
        CAttr,
        d,
        a, 
        b, 
        i;

    // update attributes, 
    // update children    

    DChildren = _slice.call(D.childNodes);   

    if (_toString.call(A[1]) === '[object Object]') {
        AAttrs    = A[1];
        AChildren = A.slice(2);
    } else {
        AChildren = A.slice(1);
    }

    if (_toString.call(B[1]) === '[object Object]') {
        BAttrs    = B[1];
        BChildren = B.slice(2);
    } else {
        BChildren = B.slice(1);
    }

    // update attributes

    for (BAttr in BAttrs) {

        if (!exists(BAttrs[BAttr])) {
            CAttrs[BAttr] = true;

        } else if (!exists(AAttrs[BAttr]) || AAttrs[BAttr] !== BAttrs[BAttr]) {

            if (BAttr === 'value' && D !== document.activeElement) {
                D.value = BAttrs[BAttr];

            } else if (BAttr === 'checked') { 
                D.checked = true;

            } else if (BAttr === 'selected') {
                D.selected = true; 

            } else if (BAttr.charAt(0) !== '_') {
                D.setAttribute(BAttr, BAttrs[BAttr]);

            } else if (BAttr = '_focus') {
                D.focus();
            }
        }
    }

    for (CAttr in CAttrs) {

        if (CAttr === 'value') {
            D.value = '';

        } else if (CAttr === 'checked') {
            D.checked = false;

        } else if (CAttr === 'selected') {
            D.selected = false;
            
        } else if (CAttr.charAt(0) !== '_') {
            D.removeAttribute(CAttr); 
            
        } else if (CAttr = '_focus') {
            D.blur();
        }
    }

    // child comparison: keyed, hash-based strategy

    if (BChildren[0] && BChildren[0][1] && BChildren[0][1]._key) {

        var AKeys = {}, AKey, BKeys = {}, BKey;

        for (i = 0; i < Math.max(AChildren.length, BChildren.length); i++) {

            d = DChildren[i];
            a = AChildren[i];
            b = BChildren[i];

            if (exists(a)) AKeys[a[1]._key] = d;
            if (exists(b)) BKeys[b[1]._key] = b;
        }

        for (AKey in AKeys) {
            if (BKeys[AKey] === undefined) D.removeChild(AKeys[AKey]);
        } 

        for (i = 0; i < BChildren.length; i++) {
            b = BChildren[i];
            if (AKeys[b[1]._key] === undefined) insertBeforeIndex(D, i, k.toHtml(b));
        }

    // child comparison: pairwise, naive strategy    

    } else { 

        for (i = 0; i < Math.max(AChildren.length, BChildren.length); i++) {

            d = DChildren[i];
            a = AChildren[i];
            b = BChildren[i];
            
            if (d === undefined && !exists(a) && exists(b)) { // no d/a, but b
                D.appendChild(k.toHtml(b)); 

            } else if (typeof d !== 'undefined' && exists(a) && !exists(b)) { // d/a, but no b
                D.removeChild(d);

            } else if (typeof d !== 'undefined' && exists(a) && exists(b)) { // both

                if ((isTag(a) && isTag(b))) { // tags

                    if (a[0] === b[0]) { // isSameTagOrId() - same tag, explore further
                        k.update(d, a, b);

                    } else {
                        D.replaceChild(k.toHtml(b), d); // different tag, regen, no need to explore further
                    }

                } else { // atoms
                    if (a !== b) {
                        D.replaceChild(k.toHtml(b), d);
                    }
                }
            }
        }
    }
};

function insertBeforeIndex (parent, i, child) {

    var next = parent.childNodes[i];

    if (next) {
        parent.insertBefore(child, next);
    } else {
        parent.appendChild(child);
    }
}


function isTag (v) {
    return v instanceof Array && typeof v[0] === 'string';
}

function exists (n) {
    if (n instanceof Array || typeof n === 'string') return n.length > 0;
    return !!(n === 0 || n);
}

function contains (arr, v) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === v) return true;
    }
}


root.vDom = vDom;


}).call(this);